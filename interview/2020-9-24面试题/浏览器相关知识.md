# 浏览器相关知识

### 1.进程与线程

1. 进程是操作系统分配资源的最小单位

2.  线程是进程中一个概念 (线程是程序执行的最小单元)

3. js引擎是单线程的 单线程(一个时间点只能干一件事情)

4. 浏览器是多进程多线程的

5. 当js引擎遇到定时器时, 会让浏览器通知异步线程来管理这个异步回调函数 js引擎继续解析下面的代码

6. 怎么管理异步回调函数?

   js 引擎执行代码，发现定时器---通知异步线程，js继续将代码走完---异步线程执行定时，设定时间完成后后将每次循环结果分别放入异步队列---Js引擎执行完代码后执行回调函数

### 2.浏览器内核+js引擎

+ 浏览器内核:
  + firefox: gecko
  + ie: trident
  + Safari: webkit
  + chrome: webkit-->基于webkit开发了blink
  + opera: pesto-->webkit-->blink
+ js引擎
  + jscore
  + v8(chrome)

### 15. 事件轮询机制

基本流程

![事件轮训机制](D:\学习\学习资料\study\事件轮训机制.png)

导图要表达的内容：

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
- 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。
- 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。( js引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue 那里检查是否有等待被调用的函数。)
- 上述过程会不断重复，也就是常说的 Event Loop (事件循环)。

宏任务与微任务

- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
- micro-task(微任务)：Promise，process.nextTick

## 补充1:  浏览器的事件轮询机制

- 作用： 用来执行异步代码
- 流程：
  - js主线程对全局代码进行预解析、预处理
    - 将var关键字声明变量提升window属性，值为undefined
    - 将function关键字声明函数，提升window方法，值为函数体
    - 将全局this赋值为window
  - 接下来开始执行代码
    - 同步代码：一行行依次执行
    - 异步代码：将给浏览器其他模块(分线程)负责管理
      - 定时器管理模块，负责计时，一旦到点就将回调函数添加到回调队列中
      - dom事件管理模块，负责绑定事件，一旦事件被触发，就将回调函数添加到回调队列中
  - 执行完所有代码后，轮询回调队列，对其中的回调函数做处理（依次取出，同步执行）
  - 如果执行完毕或者空队列，等待一会在接下来继续访问回调队列，不断轮询这个过程

### 19. 同步、异步和事件循环

基础：

- javascript是一门单线程语言
- Event Loop是javascript的执行机制

一个异步过程：

1. 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；

2. 主线程可以继续执行后面的代码，同时工作线程执行异步任务；

3. 工作线程完成工作后，通知主线程（利用消息队列和事件循环，工作线程将消息放到消息队列，主线程通过事件循环过程去取消息）；

4. 主线程收到通知后（主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。），执行一定的动作(调用回调函数)。

   - **消息队列**：消息队列是一个先进先出的队列，它里面存放着各种消息。
   - **事件循环**：事件循环是指主线程重复从消息队列中取消息、执行的过程。消息队列中的每条消息实际上都对应着一个事件。

   从生产者与消费者的角度看，异步过程是这样的：

   > 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。

   同步和异步的区别：同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。

## 补充2:  nodejs的事件轮询机制

https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/

- 定时器阶段
  - 执行定时器的回调函数
- 待定回调阶段
  - 执行延迟到下一个循环迭代的 I/O 回调。
  - TCP错误回调
- idea/prepare
  - 系统使用的
- 轮询阶段
  - 轮询（回调）队列：需要将来执行的回调函数
    - 轮询轮询（回调）队列，看是否由回调函数要执行
      - 轮询（回调）队列有内容
        - 依次取出、同步执行
        - 直到轮询（回调）队列为空，或者达到系统最大限制（崩溃了）
      - 轮询（回调）队列没有内容
        - 如果之前设置过setImmediate函数，就去下一个阶段
        - 如果没有设置过，就在当前阶段等待（等待新的回调函数被添加进来）
        - 特例：如果定时器到点了，也会去下一个阶段
- 检查阶段
  - 执行setImmediate回调函数
- 关闭阶段
  - 一些准备关闭的回调函数，如：socket.on('close', ...)。
  - 关闭回调函数 close end

## 补充3. 什么是宏任务，微任务

https://juejin.im/post/5b73d7a6518825610072b42b

- 宏任务：
  - setTimeout
  - setInterval
  - setImmediate (浏览器没有，只有nodejs中有)
- 微任务
  - process.nextTick()  (浏览器没有，只有nodejs中有)
  - promise.then().catch()
- 执行流程
  - 先检查是否有微任务，如果有就执行，直到没有微任务
  - 再检查是否有宏任务，如果有就执行，执行完后又检查是否又微任务
  - 特殊：
    - 微任务有多个，默认从前到后
    - process.nextTick优先级最高
    - 微任务（第一层）中套微任务（第二层），先第一层，再第二层
    - 宏任务setTimeout、setImmediate执行先后顺序不能准确确定
      - 添加回调函数这个工作不是轮询机制完成的
      - 代码是先添加进行再执行，还是先执行再添加，确定不了

### 16. 跨域

什么是同源策略？
同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

同源策略限制以下几种行为：

```
1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
```

跨域原因: 协议/ 域名/ 端口号不一致

跨域解决方案:

1. 通过jsonp

   通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

   ```
    <script>
       var script = document.createElement('script');
       script.type = 'text/javascript';

       // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
       script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
       document.head.appendChild(script);

       // 回调执行函数
       function handleCallback(res) {
           alert(JSON.stringify(res));
       }
    </script>
   ```

2. 跨域资源共享CORS

3. nginx代理

   ##### nginx配置解决iconfont跨域

   浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。

   ```
   location / {
     add_header Access-Control-Allow-Origin *;
   }
   ```

   ##### nginx反向代理接口跨域

   跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

   实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

4. nodejs中间件代理

   node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

### 18. http与https

1. HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。
2. HTTP是基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）
3. HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS![http与https](D:\学习\学习资料\study\http与https.png)
4. HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
5. HTTP默认的端口号为80，HTTPS的端口号为443。

**一次HTTP操作称为一个事务，其工作过程大概如下：** 

1. 用户在浏览器中键入需要访问网页的URL或者点击某个网页中链接；
2. 浏览器根据URL中的域名，通过DNS解析出目标网页的IP地址；

```
浏览器请求这个页面：http://hackr.ip/index.html
在这一步，需要域名系统DNS解析域名hackr.ip,得主机的IP地址 20X.189.105.112。
然后将上面结合本机自己的信息，封装成一个http请求数据包
复制代码
```

1. 在HTTP开始工作前，客户端首先会通过TCP/IP协议来和服务端建立链接（TCP三次握手）
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4. 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：`Connection:keep-alive`，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽

http通信风险:

（1） **窃听风险**（eavesdropping）：第三方可以获知通信内容。

（2） **篡改风险**（tampering）：第三方可以修改通信内容。

（3） **冒充风险**（pretending）：第三方可以冒充他人身份参与通信。

SSL/ TLS 协议就是为了解决三大风险而设计:

（1） 所有信息都是**加密传播**，第三方无法窃听。

（2） 具有**校验机制**，一旦被篡改，通信双方会立刻发现。

（3） 配备**身份证书**，防止身份被冒充。

SSL/ TLS 基本的运行过程: SSL/TLS 协议的基本思路是采用[公钥加密法](http://en.wikipedia.org/wiki/Public-key_cryptography)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

```
（1） 客户端向服务器端索要并验证公钥。(客户端发请求 + 服务器回应: 生成密钥的随机数)
（2） 双方协商生成"对话密钥"。(客户端回应:验证服务器证书, 生成对话密钥 + 服务端回应: 计算成成对话密钥)
（3） 双方采用"对话密钥"进行加密通信。
```

（1）如何保证公钥不被篡改？

公钥放在[数字证书](http://en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。

（2）公钥加密计算量太大，如何减少耗用的时间？

每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

1. **讲解https的工作原理?** 

   HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：

   - 浏览器将自己支持的一套加密规则发送给网站。
   - 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
   - 获得网站证书之后浏览器要做以下工作：
     - a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
     - 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
     - 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
   - 网站接收浏览器发来的数据之后要做以下的操作：
     - a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
     - b) 使用密码加密一段握手消息，发送给浏览器。
   - 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

2. **讲解一下https对称加密和非对称加密?** 

   对称加密：发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。

   非对称加密：接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。

   在网站通过SSL来与用户建立安全的通信中，对称加密算法和非对称加密算法起到了很大作用。

## 1、谈谈路由

- 是什么
  - 一种key-value映射关系。key指的是路由路径，value指的是回调函数
- 作用：
  - 定义请求地址
  - 处理请求、返回响应
- 组成
  - 请求方式 GET / POST / PUT / DETELE
  - 请求地址/路由路径 '/'  --> 'http://localhost:3000/'
  - 若干个回调函数 
    - request 请求信息 浏览器发送服务器
      - req.query 获取查询字符串参数
      - req.params 获取params参数 /hotel/:id
      - req.body 获取POST请求的请求体参数
      - req.headers 获取请求头信息
    - response 响应信息 服务器发送浏览器
      - res.send() 根据响应的内容，自动处理
      - res.end()  快速返回响应
      - res.json() 将js对象/数组转化成json数据返回
      - res.download() 将响应的文件提供浏览器自动下载
      - res.sendFile() 将响应的文件提供浏览器自动打开
      - res.redirect() 重定向到其他资源地址，默认响应状态码302
      - 以上都是返回响应方法，一旦调用，服务器就会返回响应给浏览器（所以一般不在方法后面写代码，还要保证返回响应的方法只能调用一个）
      - res.set(key, value) 设置响应头
      - res.status() 设置响应状态码
- 使用
  - app.get('/', (req, res, next) => {})
  - app.post('/login', (req, res) => {})
  - app.get('/hotel/:id', (req, res) => {})  多个路径对应一个路由处理

## 4、谈谈WEB存储技术

## cookie

1. 是什么？
   - 本质上是一个存储浏览器端的文本
2. 作用：
   - 可以用来给浏览器存储数据的
   - 解决http协议无状态问题
3. 工作原理
   - 首次：浏览器发送请求给服务器，服务器返回响应给浏览器，此时返回了cookie，浏览器自动保存下来
   - 下次：浏览器发送请求时就会自动携带上cookie，服务器通过解析cookie，从而判断浏览器之前的行为（是否登录过），返回给浏览器相应响应
4. 服务器端使用
   - 设置/修改cookie
     res.cookie(key, value, options)
   - 获取cookie
     app.use(cookieParser());
     req.cookies
   - 删除cookie
     res.clearCookie(key)
5. 浏览器使用
   - document.cookie 读写二合一
   - document.cookie = 'hello=123;expires=' + new Date(Date.now() + 1000 * 3600 * 24);
6. cookie的有效期
   - 会话cookie （浏览器打开到浏览器关闭是一次会话）
     - 会话开始时产生，会话结束自动销毁
   - 持久化cookie
     - res.cookie('userId', 'sunwukong', {maxAge: 1000 * 3600 * 24 * 7}); 7天内生效
     - res.cookie('userId', 'sunwukong', {maxAge: 1000 * 3600 * 24 * 365 * 10});  10年内生效，永久
7. 缺点：
   - 存储容量有限  大约4kb左右， 数量为20个左右
   - 传输流量比较大  如果cookie数量比较多，每次请求时都会自动携带cookie

## Session

1. 是什么？是一个存储服务器端会话对象
2. 作用？存储数据、解决http协议无状态问题
3. 工作原理
   - 浏览器首次发送给服务器请求，此时开启会话，服务器会为本次会话创建session对象
   - 服务器会将session的id作为cookie返回给浏览器，浏览器接受后就存起来
   - 下一次浏览器发送请求就会自动携带上cookie，服务器就要解析cookie得到session_id，
   - 通过session_id找到对应session对象，然后根据session对象中的内容返回给浏览器相应的响应
4. 使用：
   - 想将会话存储的session进行持久化储存，就得使用上数据库
   - 设置一个中间件
   - 今后通过 req.session 读写二合一
5. cookie 和 session 区别
   - 储存位置： cookie在浏览器端  session在服务器端
   - 存储容量大小： cookie较小   session无限大
   - 传输流量： cookie较多    session只产生一个cookie，较小
   - 安全性：  cookie安全更低（保存不是敏感数据）    session安全更高（登陆、注册）

## Webstorage

- SessionStorage和LocalStorage都是本地存储，不会被发送到服务器上。同时空间比Cookie大很多，一般支持5-10M
- 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。
  - Storage.getItem('key');
    - 该方法接受一个键名作为参数，返回键名对应的值。
  - Storage.setItem('key', 'value');
    - 该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。
  - Storage.removeItem('key');
    - 该方法接受一个键名作为参数，并把该键名从存储中删除。
  - Storage.clear()
    - 调用该方法会清空存储中的所有键名
    - ·：
    - Storage 对象发生变化时（即创建/更新/删除数据项时，重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件）会触发
    - 在同一个页面内发生的改变不会起作用
    - 在相同域名下的其他页面发生的改变才会起作用。(修改的页面不会触发事件，与它共享的页面会触发事件)
- 区别
  - LocalStorage是浏览器本地持久化存储技术，也叫永久存储
  - SessionStorage是浏览器本地临时存储技术，也叫会话存储
- 使用`store`库完美兼容所有浏览器

## IndexDB和WebSQL

- IndexedDB 和 WebSQL 都是用于客户端存储大量结构化数据。
- 该API使用索引来实现对该数据的高性能搜索。
- 不同的是IndexedDB是非关系型，而WebSQL是关系型。
- WebSQL官方不在维护，但兼容性较好，基本不使用。
- IndexedDB在维护，兼容性较差
- 结合`localForage`库使用IndexDB和WebStorage
- https://juejin.im/post/5bdd67206fb9a04a0c2de0c3
- https://github.com/localForage/localForage

## PWA

- 渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。
- 简单来讲：
  - 能够离线访问资源
  - 能够使用原生系统功能
- https://zoumiaojiang.com/article/amazing-workbox-3/

## Manifest

- html5 离线缓存文件
- https://juejin.im/post/59cdb48b518825788565c5f0



## ajax

- 是什么？
  - 异步的js和xml
- 作用 
  - 发送异步的请求
- xml是什么
  - 可扩展的标记语法
  - 用来储存和传递数据的
  - 已经被json取代了
- 特点
  - 不会刷新整个页面
  - 更新局部页面
  - 异步请求
  - 缺点：
  - 没有浏览历史记录，不能回退
  - 存在跨域问题
  - SEO不友好
- 使用
  - 创建xhr对象  new XMLHttpRequest()
  - 绑定事件监听 readystatechange
    - content-type的值
      - application/x-www-form-urlencoded form表单提交的方式 通常位于请求头
      - application/json 数据是json格式 通常位于响应头
      - text/html 是html内容 通常位于响应头
      - text/javascript
      - text/css
      - image/jpg
  - 设置请求信息 xhr.open(请求方式, 请求地址)  xhr.setRequestHeader()
  - 发送请求 xhr.send(post请求体信息)

## jquery

- $.get/post(请求地址[，请求参数]，成功的回调函数)




### 








